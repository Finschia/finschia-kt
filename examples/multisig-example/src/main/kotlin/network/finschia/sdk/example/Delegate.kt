package network.finschia.sdk.example

import com.google.protobuf.ByteString
import io.grpc.ManagedChannelBuilder
import kotlinx.serialization.json.Json
import kotlinx.serialization.json.encodeToJsonElement
import network.finschia.sdk.account.HDWallet
import network.finschia.sdk.account.KeyWallet
import network.finschia.sdk.legacymultisig.*
import org.bouncycastle.jcajce.provider.digest.SHA256


class MultisigMsgDelegate {
    companion object {
        fun createMsgDelegate(
            delegatorAddress: String,
            validatorAddress: String,
            amounts: cosmos.base.v1beta1.CoinOuterClass.Coin
        ): cosmos.staking.v1beta1.Tx.MsgDelegate {
            return cosmos.staking.v1beta1.msgDelegate {
                this.delegatorAddress = delegatorAddress
                this.validatorAddress = validatorAddress
                this.amount = amounts
            }
        }
        fun convertMsgDelegatorToAminoMsg(msgDelegate: cosmos.staking.v1beta1.Tx.MsgDelegate): AminoMsg {

            val jsonAminoMsgDelegateValue = AminoMsgDelegateValue(
                delegatorAddress = msgDelegate.delegatorAddress,
                validatorAddress = msgDelegate.validatorAddress,
                amount = Coin(
                    denom = msgDelegate.amount.denom,
                    amount = msgDelegate.amount.amount
                )

            )

            return AminoMsg(
                type = "cosmos-sdk/MsgDelegate",
                value = Json.encodeToJsonElement(jsonAminoMsgDelegateValue)
            )
        }

        fun generateTxBody(
            delegateMsg: cosmos.staking.v1beta1.Tx.MsgDelegate,
            timeoutHeight: Int
        ): cosmos.tx.v1beta1.TxOuterClass.TxBody {
            return cosmos.tx.v1beta1.txBody {
                this.messages += com.google.protobuf.any {
                    this.typeUrl = "/cosmos.staking.v1beta1.MsgDelegate"
                    this.value = delegateMsg.toByteString()
                }
                this.timeoutHeight = timeoutHeight.toLong()
            }
        }

        fun getSignDigest(signDoc: StdSignDoc): ByteArray {
            return SHA256.Digest()
                .digest(Json.encodeToJsonElement(signDoc).removeNull().sort().toString().toByteArray())
        }

        fun generateSignDoc(
            sendMsgs: List<cosmos.staking.v1beta1.Tx.MsgDelegate>,
            accNum: Int,
            accSeq: Int,
            timeoutHeight: Int = 0,
            gasLimit: Int,
            chainId: String
        ): StdSignDoc {
            return StdSignDoc(
                accountNumber = accNum.toString(),
                sequence = accSeq.toString(),
                timeoutHeight = if (timeoutHeight <= 0) null else timeoutHeight.toString(),
                chainId = chainId,
                memo = "",
                fee = StdFee(
                    amount = listOf(Coin(amount = "20", denom = "cony")),
                    gas = gasLimit.toString(),
                ),
                msgs = sendMsgs.map { convertMsgDelegatorToAminoMsg(it) },
            )
        }
    }
}

suspend fun main() {
    //-----------------------------------------
    // Step 1: setup GRPC and initialize scenario data
    //-----------------------------------------
    val port = 9090
    val host = "localhost"
    val channel = ManagedChannelBuilder.forAddress(host, port).usePlaintext().build()
    val chainId = "sim"
    val gasLimit = 200000
    val accountPrefix = "link"

    // set up HD wallet
    val mnemonic =
        "mind flame tobacco sense move hammer drift crime ring globe art gaze cinnamon helmet cruise special produce notable negative wait path scrap recall have"
    val hdWallet = HDWallet.loadFromMnemonic(mnemonic)

    // multi-sig threshold
    val threshold = 2
    // number of multi-sig public keys
    val pubKeyNum = 5
    // wallet list with pubKeyNum wallets
    val wallets: List<KeyWallet> = List(pubKeyNum) { 0 }.mapIndexed() { index, _ ->
        hdWallet.getKeyWallet(index = index)
    }
    // public key list with pubKeyNum public keys
    val pubKeyList = wallets.map {
        encodeSecp256k1Pubkey(it.pubKey.body)
    }
    // signer wallet list with threshold wallets
    val signers = wallets.filterIndexed { index, _ -> index < threshold }

    // multi-sig public key
    //
    // You need to input `txSigLimit`. `txSigLimit` means the upper limit of multi-sig public key number.
    // `txSigLimit` is different for each chain. Please check your chain `txSigLimit` with reference to
    // https://github.com/Finschia/finschia-sdk/blob/main/x/auth/spec/07_client.md#params-1.
    //
    // `pubKeylist` size should not exceed the upper limit. If it exceeds the upper limit, you will not
    // be able to remit payment from the address generated by its `pubKeylist`. This means that the assets
    // cannot be retrieved from the address.
    //
    // For more information:
    // https://hub.cosmos.network/main/governance/params-change/Auth.html#txsiglimit
    // https://docs.cosmos.network/v0.45/modules/auth/03_antehandlers.html
    // https://docs.cosmos.network/v0.45/modules/auth/07_params.html
    val multiSigPubKey = createMultisigThresholdPubkey(pubKeyList, threshold, txSigLimit = 7)
    // multi-sig address
    val multiSigAddress = pubkeyToAddress(multiSigPubKey, accountPrefix)
    val multiSigAccNum = 9
    var multiSigAccSeq = 0
    val timeoutHeight = 0

    val fundAmount = 1
    val stakeDenom = "stake"
    // scenario description
    val validatorAddress = "linkvaloper146asaycmtydq45kxc8evntqfgepagygeddajpy" //change for yourself
    println(
        "scenario: " +
                "$multiSigAddress ($threshold of $pubKeyNum multi-sig address, acc num: $multiSigAccNum, acc seq: $multiSigAccSeq) delegate $fundAmount$stakeDenom to $validatorAddress on $chainId chain. " +
                "Gas limit is set to $gasLimit and timeout height is ${if (timeoutHeight <= 0) "not set" else "set to $timeoutHeight"}."
    )

    //-----------------------------------------
    // step 2: generate `MsgDelegate` unsigned tx
    //-----------------------------------------
    // generate sendDelegate
    val msgDelegate = MultisigMsgDelegate.createMsgDelegate(
        multiSigAddress,
        validatorAddress,
        cosmos.base.v1beta1.coin {
            this.amount = fundAmount.toString()
            this.denom = stakeDenom
        }
    )

    // generate unsigned tx body(amino type)
    val txDelegateBody = MultisigMsgDelegate.generateTxBody(msgDelegate, timeoutHeight)

    // generate amino signDoc
    val delegateUnsignedSignDoc = MultisigMsgDelegate.generateSignDoc(
        listOf(msgDelegate),
        multiSigAccNum,
        multiSigAccSeq,
        timeoutHeight,
        gasLimit,
        chainId
    )

    //-----------------------------------------
    // step 3: generate signature digest
    //-----------------------------------------
    val signDigestDelegate = MultisigMsgDelegate.getSignDigest(delegateUnsignedSignDoc)

    //-----------------------------------------
    // step 4: sign
    //-----------------------------------------
    val signerToSigsDelegate: Map<String, ByteString> = signers.map {
        it.address.toBech32(accountPrefix) to ByteString.copyFrom(it.sign(signDigestDelegate).copyOfRange(0, 64))
    }.toMap()

    //-----------------------------------------
    // step 5: generate signed tx
    //-----------------------------------------
    val signedDelegateTx = makeMultisignedTx(
        multiSigPubKey,
        multiSigAccSeq,
        delegateUnsignedSignDoc.fee,
        txDelegateBody.toByteString(),
        signerToSigsDelegate
    )

    //-----------------------------------------
    // step 6: broadcast the signed tx
    //-----------------------------------------
    val resultDelegate = TxClient(channel).use { it.broadcastTx(signedDelegateTx) }
    println("result: $resultDelegate")
}
